=== Example 02: Attributes

Consider the Franca IDL specification of example 2:

[source,java]
----
package commonapi.examples

interface E02Attributes {
	version { major 1 minor 0 }

	attribute Int32 x
	attribute CommonTypes.a1Struct a1
}

typeCollection CommonTypes {
	version { major 1 minor 0 }
	
	struct a1Struct {
		String s
		a2Struct a2
	}

	struct a2Struct {
		Int32 a
		Boolean b
		Double d
	}
}
----

Modelling attributes in interfaces means in general that the service that implements this interface has an internal state which shall be visible for external clients like a HMI (Human Machine Interface). A developer of a client would normally expect that he can set and get the attribute and that he can notify or subscribe to changes of the value of the attribute. We will see below in the implementation how exactly this is realized by CommonAPI. Franca offers two key words that indicate exactly how the attribute can be accessed: +readonly+ and +noSubscriptions+. The default setting is that everything is allowed; with these two additional key words these possibilities can be limited (e.g. if someone tries to call a set method and the attribute is +readonly+ he will get an error at compile time).

The nested structure +a1Struct+ is defined in a type collection +CommonTypes+. Structures can be defined just like other type definitions within an interface definition or outside in a type collection. Since Franca 0.8.9 type collections can also be anonymous (without name). A type collection is transferred by the CommonAPI code generator in an additional namespace.

The Franca interface specification of attributes does not contain any information about whether the access from client side is synchronous or asynchronous or whether the attribute is cached by the proxy. CommonAPI provides always methods for synchronous and asynchronous setter and getter methods; caching can be realized via an API extension.

Now let's have a look to the CommonAPI code on the service side. The default implementation of the stub which is generated by the CommonAPI code generator defines the attribute as private attribute of the stub class. This attribute can be accessed from the stub implementation via getter and setter functions. Additionally the API for the stub implementation provides some callbacks (the following code snippet shows parts of the generated header of the stub class which refer to the attribute x):

[source,{cppstr}]
----
class E02AttributesStubDefault : public virtual E02AttributesStub {
public:
    /* some other code here */
    virtual const int32_t& getXAttribute();
    virtual const int32_t& getXAttribute(const std::shared_ptr<CommonAPI::ClientId> _client);
    virtual void setXAttribute(int32_t _value);
    virtual void setXAttribute(const std::shared_ptr<CommonAPI::ClientId> _client, int32_t _value);

protected:
    /* some other code here */
    virtual bool trySetXAttribute(int32_t _value);
    virtual bool validateXAttributeRequestedValue(const int32_t &_value);
    virtual void onRemoteXAttributeChanged();

private:
    /* some other code here */
    int32_t xAttributeValue_;
};
----

If the implementation of the stub has to change the value of the attribute +x+, let's say in a class +E02AttributesStubImpl+ that is derived from +E02AttributesStubDefault+, then it can call +setXAttribute+ (analog the usage of +getXAttribute+). The callback +onRemoteXAttributeChanged+ informs that a change of the attribute +x+ has been completed. The other callbacks can prevent the set of the attribute (+validateXAttributeRequestedValue+) or change the given value from the client (+trySetXAttribute+).

In the example the service increments a counter every 2 seconds and publishes the counter value via the interface attribute +x+.

Now see the implementation of the client. The simplest case is to get the current value of +x+. The following extract shows one part of the main function:

[source,{cppstr}]
----
#include <CommonAPI/CommonAPI.hpp>
#include <CommonAPI/AttributeCacheExtension.hpp>
#include <v1/commonapi/examples/E02AttributesProxy.hpp>
using namespace v1::commonapi::examples;

void recv_cb(const CommonAPI::CallStatus& callStatus, const int32_t& val) {
    std::cout << "Receive callback: " << val << std::endl;
}

void recv_cb_s(const CommonAPI::CallStatus& callStatus, const CommonTypes::a1Struct& valStruct) {
    std::cout << "Receive callback for structure: a1.s = " << valStruct.getS()
              << ", valStruct.a2.b = " << (valStruct.getA2().getB() ? "TRUE" : "FALSE")
              << ", valStruct.a2.d = " << valStruct.getA2().getD()
              << std::endl;
}

int main() {
    std::shared_ptr < CommonAPI::Runtime > runtime = CommonAPI::Runtime::get();

    std::string domain = "local";
    std::string instance = "commonapi.examples.Attributes"; 
    std::string connection = "client-sample";
    auto myProxy = runtime->buildProxyWithDefaultAttributeExtension<E02AttributesProxy, CommonAPI::Extensions::AttributeCacheExtension>(domain, instance, connection);

    std::cout << "Waiting for service to become available." << std::endl;
    while (!myProxy->isAvailable()) {
        std::this_thread::sleep_for(std::chrono::microseconds(10));
    }
    CommonAPI::CallStatus callStatus;

    int32_t value = 0;

    CommonAPI::CallInfo info(1000);
    info.sender_ = 5678;

    // Get actual attribute value from service
    std::cout << "Getting attribute value: " << value << std::endl;
    myProxy->getXAttribute().getValue(callStatus, value, &info);
    if (callStatus != CommonAPI::CallStatus::SUCCESS) {
        std::cerr << "Remote call A failed!\n";
        return -1;
    }
    std::cout << "Got attribute value: " << value << std::endl;

    // Subscribe for receiving values
    myProxy->getXAttribute().getChangedEvent().subscribe([&](const int32_t& val) {
        std::cout << "Received change message: " << val << std::endl;
    });

    myProxy->getA1Attribute().getChangedEvent().subscribe([&](const CommonTypes::a1Struct& val) {
        std::cout << "Received change message for A1" << std::endl;
    });

    value = 100;

    // Asynchronous call to set attribute of service
    std::function<void(const CommonAPI::CallStatus&, int32_t)> fcb = recv_cb;
    myProxy->getXAttribute().setValueAsync(value, fcb, &info);

    // Asynchronous call to set attribute of type structure in service
    CommonTypes::a1Struct valueStruct;

    valueStruct.setS("abc");
    CommonTypes::a2Struct a2Struct = valueStruct.getA2();
    a2Struct.setA(123);
    a2Struct.setB(true);
    a2Struct.setD(1234);
    valueStruct.setA2(a2Struct);

    std::function<void(const CommonAPI::CallStatus&, CommonTypes::a1Struct)> fcb_s = recv_cb_s;
    myProxy->getA1Attribute().setValueAsync(valueStruct, fcb_s, &info);

    while (true) {
        int32_t errorValue = -1;
        int32_t valueCached = *myProxy->getXAttributeExtension().getCachedValue(errorValue);
        if (valueCached != errorValue) {
            std::cout << "Got cached attribute value[" << (int)valueCached << "]: " << valueCached << std::endl;
        } else {
            std::cout << "Got cached attribute error value[" << (int)valueCached << "]: " << valueCached << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::microseconds(1000000));
    }
}
----
The +getXAttribute+ method will deliver the type +XAttribute+ which has to be used for the access to +x+. Every access returns a flag named callStatus (please see the CommonAPI specification). Subscription requires in general the definition of a callback function which is called in case of an attribute change. The subscribe method of CommonAPI requires a function object; for a compact notation this function object can be defined as lambda function.

Of course it is also possible to define a separate callback function with an user-defined name (here recv_cb) as can be seen at the asynchronous set call for the attribute +x+:

[source,{cppstr}]
----
void recv_cb(const CommonAPI::CallStatus& callStatus, const int32_t& val) {
    std::cout << "Receive callback: " << val << std::endl;
}

.... // main method

value = 100;
// Asynchronous call to set attribute of service
std::function<void(const CommonAPI::CallStatus&, int32_t)> fcb = recv_cb;
myProxy->getXAttribute().setValueAsync(value, fcb, &info);
----

This example uses a special feature of CommonAPI which is called _Attribute Extension_. This feature is described separately. At this point we do not want to go into more detail. Please see the source code of the example for a deeper insight.

